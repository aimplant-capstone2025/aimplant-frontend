"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/find-my-way-ts";
exports.ids = ["vendor-chunks/find-my-way-ts"];
exports.modules = {

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js":
/*!*************************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/QueryString.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * @since 1.0.0\n */\n// Taken from https://github.com/anonrig/fast-querystring under MIT License\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = /*#__PURE__*/Object.create(null);\n/**\n * @category parsing\n * @since 1.0.0\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  const inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n      key = input.slice(startingIndex + 1, equalityIndex);\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = decodeURIComponent(key) || key;\n        }\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n          if (shouldDecodeValue) {\n            value = decodeURIComponent(value) || value;\n          }\n        }\n        const currentValue = result[key];\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n  return result;\n}\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\" || type === \"boolean\") {\n    return \"\" + value;\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n  return \"\";\n}\n/**\n * @category encoding\n * @since 1.0.0\n */\nfunction stringify(input) {\n  let result = \"\";\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n    if (i) {\n      result += separator;\n    }\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n  return result;\n}\n// -----------------------------------------------------------------------------\n// This has been taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\nconst hexTable = /*#__PURE__*/Array.from({\n  length: 256\n}, (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase());\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// biome-ignore format: the array should not be formatted\nconst noEscape = /*#__PURE__*/new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 16 - 31\n0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0,\n// 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n// 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,\n// 80 - 95\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0 // 112 - 127\n]);\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n      if (++i === len) break outer;\n      c = str.charCodeAt(i);\n    }\n    if (lastPos < i) out += str.slice(lastPos, i);\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out += hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n    const c2 = str.charCodeAt(i) & 0x3ff;\n    lastPos = i + 1;\n    c = 0x10000 + ((c & 0x3ff) << 10 | c2);\n    out += hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n//# sourceMappingURL=QueryString.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vUXVlcnlTdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haW1wbGFudC8uL25vZGVfbW9kdWxlcy9maW5kLW15LXdheS10cy9kaXN0L2VzbS9RdWVyeVN0cmluZy5qcz8zZDRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Fub25yaWcvZmFzdC1xdWVyeXN0cmluZyB1bmRlciBNSVQgTGljZW5zZVxuY29uc3QgcGx1c1JlZ2V4ID0gL1xcKy9nO1xuY29uc3QgRW1wdHkgPSBmdW5jdGlvbiAoKSB7fTtcbkVtcHR5LnByb3RvdHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgcGFyc2luZ1xuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAvLyBPcHRpbWl6YXRpb246IFVzZSBuZXcgRW1wdHkoKSBpbnN0ZWFkIG9mIE9iamVjdC5jcmVhdGUobnVsbCkgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIHY4IGhhcyBhIGJldHRlciBvcHRpbWl6YXRpb24gZm9yIGluaXRpYWxpemluZyBmdW5jdGlvbnMgY29tcGFyZWQgdG8gT2JqZWN0XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgbGV0IGtleSA9IFwiXCI7XG4gIGxldCB2YWx1ZSA9IFwiXCI7XG4gIGxldCBzdGFydGluZ0luZGV4ID0gLTE7XG4gIGxldCBlcXVhbGl0eUluZGV4ID0gLTE7XG4gIGxldCBzaG91bGREZWNvZGVLZXkgPSBmYWxzZTtcbiAgbGV0IHNob3VsZERlY29kZVZhbHVlID0gZmFsc2U7XG4gIGxldCBrZXlIYXNQbHVzID0gZmFsc2U7XG4gIGxldCB2YWx1ZUhhc1BsdXMgPSBmYWxzZTtcbiAgbGV0IGhhc0JvdGhLZXlWYWx1ZVBhaXIgPSBmYWxzZTtcbiAgbGV0IGMgPSAwO1xuICAvLyBIYXZlIGEgYm91bmRhcnkgb2YgaW5wdXQubGVuZ3RoICsgMSB0byBhY2Nlc3MgbGFzdCBwYWlyIGluc2lkZSB0aGUgbG9vcC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dExlbmd0aCArIDE7IGkrKykge1xuICAgIGMgPSBpICE9PSBpbnB1dExlbmd0aCA/IGlucHV0LmNoYXJDb2RlQXQoaSkgOiAzODtcbiAgICAvLyBIYW5kbGUgJyYnIGFuZCBlbmQgb2YgbGluZSB0byBwYXNzIHRoZSBjdXJyZW50IHZhbHVlcyB0byByZXN1bHRcbiAgICBpZiAoYyA9PT0gMzgpIHtcbiAgICAgIGhhc0JvdGhLZXlWYWx1ZVBhaXIgPSBlcXVhbGl0eUluZGV4ID4gc3RhcnRpbmdJbmRleDtcbiAgICAgIC8vIE9wdGltaXphdGlvbjogUmV1c2UgZXF1YWxpdHkgaW5kZXggdG8gc3RvcmUgdGhlIGVuZCBvZiBrZXlcbiAgICAgIGlmICghaGFzQm90aEtleVZhbHVlUGFpcikge1xuICAgICAgICBlcXVhbGl0eUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGtleSA9IGlucHV0LnNsaWNlKHN0YXJ0aW5nSW5kZXggKyAxLCBlcXVhbGl0eUluZGV4KTtcbiAgICAgIC8vIEFkZCBrZXkvdmFsdWUgcGFpciBvbmx5IGlmIHRoZSByYW5nZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiAxOyBhLmsuYS4gY29udGFpbnMgYXQgbGVhc3QgXCI9XCJcbiAgICAgIGlmIChoYXNCb3RoS2V5VmFsdWVQYWlyIHx8IGtleS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogUmVwbGFjZSAnKycgd2l0aCBzcGFjZVxuICAgICAgICBpZiAoa2V5SGFzUGx1cykge1xuICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKHBsdXNSZWdleCwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogRG8gbm90IGRlY29kZSBpZiBpdCdzIG5vdCBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChzaG91bGREZWNvZGVLZXkpIHtcbiAgICAgICAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KSB8fCBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0JvdGhLZXlWYWx1ZVBhaXIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGlucHV0LnNsaWNlKGVxdWFsaXR5SW5kZXggKyAxLCBpKTtcbiAgICAgICAgICBpZiAodmFsdWVIYXNQbHVzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocGx1c1JlZ2V4LCBcIiBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGREZWNvZGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIHx8IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSByZXN1bHRba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IHZhbHVlLnBvcCBpcyBmYXN0ZXIgdGhhbiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUucG9wKSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gW2N1cnJlbnRWYWx1ZSwgdmFsdWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVzZXQgcmVhZGluZyBrZXkgdmFsdWUgcGFpcnNcbiAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIHN0YXJ0aW5nSW5kZXggPSBpO1xuICAgICAgZXF1YWxpdHlJbmRleCA9IGk7XG4gICAgICBzaG91bGREZWNvZGVLZXkgPSBmYWxzZTtcbiAgICAgIHNob3VsZERlY29kZVZhbHVlID0gZmFsc2U7XG4gICAgICBrZXlIYXNQbHVzID0gZmFsc2U7XG4gICAgICB2YWx1ZUhhc1BsdXMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgJz0nXG4gICAgZWxzZSBpZiAoYyA9PT0gNjEpIHtcbiAgICAgIGlmIChlcXVhbGl0eUluZGV4IDw9IHN0YXJ0aW5nSW5kZXgpIHtcbiAgICAgICAgZXF1YWxpdHlJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICAvLyBJZiAnPScgY2hhcmFjdGVyIG9jY3VycyBhZ2Fpbiwgd2Ugc2hvdWxkIGRlY29kZSB0aGUgaW5wdXQuXG4gICAgICBlbHNlIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlVmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayAnKycsIGFuZCByZW1lbWJlciB0byByZXBsYWNlIGl0IHdpdGggZW1wdHkgc3BhY2UuXG4gICAgZWxzZSBpZiAoYyA9PT0gNDMpIHtcbiAgICAgIGlmIChlcXVhbGl0eUluZGV4ID4gc3RhcnRpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZUhhc1BsdXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5SGFzUGx1cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrICclJyBjaGFyYWN0ZXIgZm9yIGVuY29kaW5nXG4gICAgZWxzZSBpZiAoYyA9PT0gMzcpIHtcbiAgICAgIGlmIChlcXVhbGl0eUluZGV4ID4gc3RhcnRpbmdJbmRleCkge1xuICAgICAgICBzaG91bGREZWNvZGVWYWx1ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG91bGREZWNvZGVLZXkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0QXNQcmltaXRpdmUodmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyBMZW5ndGggY2hlY2sgaXMgaGFuZGxlZCBpbnNpZGUgZW5jb2RlU3RyaW5nIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGVuY29kZVN0cmluZyh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMWUyMSA/IFwiXCIgKyB2YWx1ZSA6IGVuY29kZVN0cmluZyhcIlwiICsgdmFsdWUpO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuLyoqXG4gKiBAY2F0ZWdvcnkgZW5jb2RpbmdcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KGlucHV0KSB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBzZXBhcmF0b3IgPSBcIiZcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0KTtcbiAgY29uc3Qga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGxldCB2YWx1ZUxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5TGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXRba2V5XTtcbiAgICBjb25zdCBlbmNvZGVkS2V5ID0gZW5jb2RlU3RyaW5nKGtleSkgKyBcIj1cIjtcbiAgICBpZiAoaSkge1xuICAgICAgcmVzdWx0ICs9IHNlcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaikge1xuICAgICAgICAgIHJlc3VsdCArPSBzZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBEaXZpZGluZyBpbnRvIG11bHRpcGxlIGxpbmVzIGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgLy8gU2luY2UgdjggZG9lcyBub3QgbmVlZCB0byBjYXJlIGFib3V0IHRoZSAnKycgY2hhcmFjdGVyIGlmIGl0IHdhcyBvbmUtbGluZXIuXG4gICAgICAgIHJlc3VsdCArPSBlbmNvZGVkS2V5O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QXNQcmltaXRpdmUodmFsdWVbal0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gZW5jb2RlZEtleTtcbiAgICAgIHJlc3VsdCArPSBnZXRBc1ByaW1pdGl2ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhpcyBoYXMgYmVlbiB0YWtlbiBmcm9tIE5vZGUuanMgcHJvamVjdC5cbi8vIEZ1bGwgaW1wbGVtZW50YXRpb24gY2FuIGJlIGZvdW5kIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFpbi9saWIvaW50ZXJuYWwvcXVlcnlzdHJpbmcuanNcbmNvbnN0IGhleFRhYmxlID0gLyojX19QVVJFX18qL0FycmF5LmZyb20oe1xuICBsZW5ndGg6IDI1NlxufSwgKF8sIGkpID0+IFwiJVwiICsgKChpIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuLy8gVGhlc2UgY2hhcmFjdGVycyBkbyBub3QgbmVlZCBlc2NhcGluZyB3aGVuIGdlbmVyYXRpbmcgcXVlcnkgc3RyaW5nczpcbi8vICEgLSAuIF8gflxuLy8gJyAoICkgKlxuLy8gZGlnaXRzXG4vLyBhbHBoYSAodXBwZXJjYXNlKVxuLy8gYWxwaGEgKGxvd2VyY2FzZSlcbi8vIGJpb21lLWlnbm9yZSBmb3JtYXQ6IHRoZSBhcnJheSBzaG91bGQgbm90IGJlIGZvcm1hdHRlZFxuY29uc3Qgbm9Fc2NhcGUgPSAvKiNfX1BVUkVfXyovbmV3IEludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbi8vIDAgLSAxNVxuMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbi8vIDE2IC0gMzFcbjAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsXG4vLyAzMiAtIDQ3XG4xLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLFxuLy8gNDggLSA2M1xuMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbi8vIDY0IC0gNzlcbjEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsXG4vLyA4MCAtIDk1XG4wLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuLy8gOTYgLSAxMTFcbjEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dKTtcbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIFwiXCI7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBsZXQgbGFzdFBvcyA9IDA7XG4gIGxldCBpID0gMDtcbiAgb3V0ZXI6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIEFTQ0lJXG4gICAgd2hpbGUgKGMgPCAweDgwKSB7XG4gICAgICBpZiAobm9Fc2NhcGVbY10gIT09IDEpIHtcbiAgICAgICAgaWYgKGxhc3RQb3MgPCBpKSBvdXQgKz0gc3RyLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgIG91dCArPSBoZXhUYWJsZVtjXTtcbiAgICAgIH1cbiAgICAgIGlmICgrK2kgPT09IGxlbikgYnJlYWsgb3V0ZXI7XG4gICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIGlmIChsYXN0UG9zIDwgaSkgb3V0ICs9IHN0ci5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAvLyBNdWx0aS1ieXRlIGNoYXJhY3RlcnMgLi4uXG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgb3V0ICs9IGhleFRhYmxlWzB4YzAgfCBjID4+IDZdICsgaGV4VGFibGVbMHg4MCB8IGMgJiAweDNmXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgb3V0ICs9IGhleFRhYmxlWzB4ZTAgfCBjID4+IDEyXSArIGhleFRhYmxlWzB4ODAgfCBjID4+IDYgJiAweDNmXSArIGhleFRhYmxlWzB4ODAgfCBjICYgMHgzZl07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gU3Vycm9nYXRlIHBhaXJcbiAgICArK2k7XG4gICAgLy8gVGhpcyBicmFuY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiBiZWNhdXNlIGFsbCBVUkxTZWFyY2hQYXJhbXMgZW50cmllc1xuICAgIC8vIHNob3VsZCBhbHJlYWR5IGJlIGNvbnZlcnRlZCB0byBVU1ZTdHJpbmcuIEJ1dCwgaW5jbHVkZWQgZm9yXG4gICAgLy8gY29tcGxldGlvbidzIHNha2UgYW55d2F5LlxuICAgIGlmIChpID49IGxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJJIG1hbGZvcm1lZFwiKTtcbiAgICB9XG4gICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmO1xuICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4M2ZmKSA8PCAxMCB8IGMyKTtcbiAgICBvdXQgKz0gaGV4VGFibGVbMHhmMCB8IGMgPj4gMThdICsgaGV4VGFibGVbMHg4MCB8IGMgPj4gMTIgJiAweDNmXSArIGhleFRhYmxlWzB4ODAgfCBjID4+IDYgJiAweDNmXSArIGhleFRhYmxlWzB4ODAgfCBjICYgMHgzZl07XG4gIH1cbiAgaWYgKGxhc3RQb3MgPT09IDApIHJldHVybiBzdHI7XG4gIGlmIChsYXN0UG9zIDwgbGVuKSByZXR1cm4gb3V0ICsgc3RyLnNsaWNlKGxhc3RQb3MpO1xuICByZXR1cm4gb3V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVlcnlTdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   make: () => (/* binding */ make)\n/* harmony export */ });\n/* harmony import */ var _internal_router_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/router.js */ \"(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js\");\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst make = _internal_router_js__WEBPACK_IMPORTED_MODULE_0__.make;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyxhQUFhLHFEQUFhO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWltcGxhbnQvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW5kZXguanM/YTVjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tIFwiLi9pbnRlcm5hbC9yb3V0ZXIuanNcIjtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gaW50ZXJuYWwubWFrZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/internal/router.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   make: () => (/* binding */ make)\n/* harmony export */ });\n/* harmony import */ var _QueryString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../QueryString.js */ \"(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js\");\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//;\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/;\n/** @internal */\nconst make = (options = {}) => new RouterImpl(options);\nclass RouterImpl {\n  constructor(options = {}) {\n    this.options = {\n      ignoreTrailingSlash: true,\n      ignoreDuplicateSlashes: true,\n      caseSensitive: false,\n      maxParamLength: 100,\n      ...options\n    };\n  }\n  options;\n  routes = [];\n  trees = {};\n  on(method, path, handler) {\n    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);\n    if (optionalParamMatch && optionalParamMatch.index !== undefined) {\n      assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, \"Optional Parameter needs to be the last parameter of the path\");\n      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, \"$1$2\");\n      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, \"$2\");\n      this.on(method, pathFull, handler);\n      this.on(method, pathOptional, handler);\n      return;\n    }\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path);\n    }\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path);\n    }\n    const methods = typeof method === \"string\" ? [method] : method;\n    for (const method of methods) {\n      this._on(method, path, handler);\n    }\n  }\n  all(path, handler) {\n    this.on(httpMethods, path, handler);\n  }\n  _on(method, path, handler) {\n    if (this.trees[method] === undefined) {\n      this.trees[method] = new StaticNode(\"/\");\n    }\n    let pattern = path;\n    if (pattern === \"*\" && this.trees[method].prefix.length !== 0) {\n      const currentRoot = this.trees[method];\n      this.trees[method] = new StaticNode(\"\");\n      this.trees[method].staticChildren[\"/\"] = currentRoot;\n    }\n    let parentNodePathIndex = this.trees[method].prefix.length;\n    let currentNode = this.trees[method];\n    const params = [];\n    for (let i = 0; i <= pattern.length; i++) {\n      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {\n        // It's a double colon\n        i++;\n        continue;\n      }\n      const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;\n      const isWildcardNode = pattern.charCodeAt(i) === 42;\n      if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {\n        let staticNodePath = pattern.slice(parentNodePathIndex, i);\n        if (!this.options.caseSensitive) {\n          staticNodePath = staticNodePath.toLowerCase();\n        }\n        staticNodePath = staticNodePath.split(\"::\").join(\":\");\n        staticNodePath = staticNodePath.split(\"%\").join(\"%25\");\n        // add the static part of the route to the tree\n        currentNode = currentNode.createStaticChild(staticNodePath);\n      }\n      if (isParametricNode) {\n        let isRegexNode = false;\n        const regexps = [];\n        let lastParamStartIndex = i + 1;\n        for (let j = lastParamStartIndex;; j++) {\n          const charCode = pattern.charCodeAt(j);\n          const isRegexParam = charCode === 40;\n          const isStaticPart = charCode === 45 || charCode === 46;\n          const isEndOfNode = charCode === 47 || j === pattern.length;\n          if (isRegexParam || isStaticPart || isEndOfNode) {\n            const paramName = pattern.slice(lastParamStartIndex, j);\n            params.push(paramName);\n            isRegexNode = isRegexNode || isRegexParam || isStaticPart;\n            if (isRegexParam) {\n              const endOfRegexIndex = getClosingParenthensePosition(pattern, j);\n              const regexString = pattern.slice(j, endOfRegexIndex + 1);\n              regexps.push(trimRegExpStartAndEnd(regexString));\n              j = endOfRegexIndex + 1;\n            } else {\n              regexps.push(\"(.*?)\");\n            }\n            const staticPartStartIndex = j;\n            for (; j < pattern.length; j++) {\n              const charCode = pattern.charCodeAt(j);\n              if (charCode === 47) break;\n              if (charCode === 58) {\n                const nextCharCode = pattern.charCodeAt(j + 1);\n                if (nextCharCode === 58) j++;else break;\n              }\n            }\n            let staticPart = pattern.slice(staticPartStartIndex, j);\n            if (staticPart) {\n              staticPart = staticPart.split(\"::\").join(\":\");\n              staticPart = staticPart.split(\"%\").join(\"%25\");\n              regexps.push(escapeRegExp(staticPart));\n            }\n            lastParamStartIndex = j + 1;\n            if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {\n              const nodePattern = isRegexNode ? \"()\" + staticPart : staticPart;\n              const nodePath = pattern.slice(i, j);\n              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);\n              i += nodePattern.length;\n              const regex = isRegexNode ? new RegExp(\"^\" + regexps.join(\"\") + \"$\") : undefined;\n              currentNode = currentNode.createParametricChild(regex, staticPart, nodePath);\n              parentNodePathIndex = i + 1;\n              break;\n            }\n          }\n        }\n      } else if (isWildcardNode) {\n        // add the wildcard parameter\n        params.push(\"*\");\n        currentNode = currentNode.createWildcardChild();\n        parentNodePathIndex = i + 1;\n        if (i !== pattern.length - 1) {\n          throw new Error(\"Wildcard must be the last character in the route\");\n        }\n      }\n    }\n    if (!this.options.caseSensitive) {\n      pattern = pattern.toLowerCase();\n    }\n    if (pattern === \"*\") {\n      pattern = \"/*\";\n    }\n    for (const existRoute of this.routes) {\n      if (existRoute.method === method && existRoute.pattern === pattern) {\n        throw new Error(`Method '${method}' already declared for route '${pattern}'`);\n      }\n    }\n    const route = {\n      method,\n      path,\n      pattern,\n      params,\n      handler\n    };\n    this.routes.push(route);\n    currentNode.addRoute(route);\n  }\n  has(method, path) {\n    const node = this.trees[method];\n    if (node === undefined) {\n      return false;\n    }\n    const staticNode = node.getStaticChild(path);\n    if (staticNode === undefined) {\n      return false;\n    }\n    return staticNode.isLeafNode;\n  }\n  find(method, path) {\n    let currentNode = this.trees[method];\n    if (currentNode === undefined) return undefined;\n    if (path.charCodeAt(0) !== 47) {\n      // 47 is '/'\n      path = path.replace(FULL_PATH_REGEXP, \"/\");\n    }\n    // This must be run before sanitizeUrl as the resulting function\n    // .sliceParameter must be constructed with same URL string used\n    // throughout the rest of this function.\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path);\n    }\n    let sanitizedUrl;\n    let querystring;\n    let shouldDecodeParam;\n    try {\n      sanitizedUrl = safeDecodeURI(path);\n      path = sanitizedUrl.path;\n      querystring = sanitizedUrl.querystring;\n      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;\n    } catch (error) {\n      return undefined;\n    }\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path);\n    }\n    const originPath = path;\n    if (this.options.caseSensitive === false) {\n      path = path.toLowerCase();\n    }\n    const maxParamLength = this.options.maxParamLength;\n    let pathIndex = currentNode.prefix.length;\n    const params = [];\n    const pathLen = path.length;\n    const brothersNodesStack = [];\n    while (true) {\n      if (pathIndex === pathLen && currentNode.isLeafNode) {\n        const handle = currentNode.handlerStorage?.find();\n        if (handle !== undefined) {\n          return {\n            handler: handle.handler,\n            params: handle.createParams(params),\n            searchParams: _QueryString_js__WEBPACK_IMPORTED_MODULE_0__.parse(querystring)\n          };\n        }\n      }\n      let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);\n      if (node === undefined) {\n        if (brothersNodesStack.length === 0) {\n          return undefined;\n        }\n        const brotherNodeState = brothersNodesStack.pop();\n        pathIndex = brotherNodeState.brotherPathIndex;\n        params.splice(brotherNodeState.paramsCount);\n        node = brotherNodeState.brotherNode;\n      }\n      currentNode = node;\n      // static route\n      if (currentNode._tag === \"StaticNode\") {\n        pathIndex += currentNode.prefix.length;\n        continue;\n      }\n      if (currentNode._tag === \"WildcardNode\") {\n        let param = originPath.slice(pathIndex);\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param);\n        }\n        params.push(param);\n        pathIndex = pathLen;\n        continue;\n      }\n      if (currentNode._tag === \"ParametricNode\") {\n        let paramEndIndex = originPath.indexOf(\"/\", pathIndex);\n        if (paramEndIndex === -1) {\n          paramEndIndex = pathLen;\n        }\n        let param = originPath.slice(pathIndex, paramEndIndex);\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param);\n        }\n        if (currentNode.regex !== undefined) {\n          const matchedParameters = currentNode.regex.exec(param);\n          if (matchedParameters === null) continue;\n          for (let i = 1; i < matchedParameters.length; i++) {\n            const matchedParam = matchedParameters[i];\n            if (matchedParam.length > maxParamLength) {\n              return undefined;\n            }\n            params.push(matchedParam);\n          }\n        } else {\n          if (param.length > maxParamLength) {\n            return undefined;\n          }\n          params.push(param);\n        }\n        pathIndex = paramEndIndex;\n      }\n    }\n  }\n}\nclass HandlerStorage {\n  handlers = [];\n  unconstrainedHandler;\n  find() {\n    return this.unconstrainedHandler;\n  }\n  add(route) {\n    const handler = {\n      params: route.params,\n      handler: route.handler,\n      createParams: compileCreateParams(route.params)\n    };\n    this.handlers.push(handler);\n    this.unconstrainedHandler = this.handlers[0];\n  }\n}\nclass NodeBase {\n  isLeafNode = false;\n  routes;\n  handlerStorage;\n  addRoute(route) {\n    if (this.routes === undefined) {\n      this.routes = [route];\n    } else {\n      this.routes.push(route);\n    }\n    if (this.handlerStorage === undefined) {\n      this.handlerStorage = new HandlerStorage();\n    }\n    this.isLeafNode = true;\n    this.handlerStorage.add(route);\n  }\n}\nclass ParentNode extends NodeBase {\n  staticChildren = {};\n  findStaticMatchingChild(path, pathIndex) {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)];\n    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n      return undefined;\n    }\n    return staticChild;\n  }\n  getStaticChild(path, pathIndex = 0) {\n    if (path.length === pathIndex) {\n      return this;\n    }\n    const staticChild = this.findStaticMatchingChild(path, pathIndex);\n    if (staticChild === undefined) {\n      return undefined;\n    }\n    return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);\n  }\n  createStaticChild(path) {\n    if (path.length === 0) {\n      return this;\n    }\n    let staticChild = this.staticChildren[path.charAt(0)];\n    if (staticChild) {\n      let i = 1;\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i);\n          break;\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i));\n    }\n    const label = path.charAt(0);\n    this.staticChildren[label] = new StaticNode(path);\n    return this.staticChildren[label];\n  }\n}\nclass StaticNode extends ParentNode {\n  _tag = \"StaticNode\";\n  constructor(prefix) {\n    super();\n    this.setPrefix(prefix);\n  }\n  prefix;\n  matchPrefix;\n  parametricChildren = [];\n  wildcardChild;\n  setPrefix(prefix) {\n    this.prefix = prefix;\n    if (prefix.length === 1) {\n      this.matchPrefix = (_path, _pathIndex) => true;\n    } else {\n      const len = prefix.length;\n      this.matchPrefix = function (path, pathIndex) {\n        for (let i = 1; i < len; i++) {\n          if (path.charCodeAt(pathIndex + i) !== this.prefix.charCodeAt(i)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n  }\n  getParametricChild(regex) {\n    if (regex === undefined) {\n      return this.parametricChildren.find(child => child.isRegex === false);\n    }\n    const source = regex.source;\n    return this.parametricChildren.find(child => {\n      if (child.regex === undefined) {\n        return false;\n      }\n      return child.regex.source === source;\n    });\n  }\n  createParametricChild(regex, staticSuffix, nodePath) {\n    let child = this.getParametricChild(regex);\n    if (child !== undefined) {\n      child.nodePaths.add(nodePath);\n      return child;\n    }\n    child = new ParametricNode(regex, staticSuffix, nodePath);\n    this.parametricChildren.push(child);\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1;\n      if (!child2.isRegex) return -1;\n      if (child1.staticSuffix === undefined) return 1;\n      if (child2.staticSuffix === undefined) return -1;\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;\n      return 0;\n    });\n    return child;\n  }\n  createWildcardChild() {\n    if (this.wildcardChild === undefined) {\n      this.wildcardChild = new WildcardNode();\n    }\n    return this.wildcardChild;\n  }\n  split(parentNode, length) {\n    const parentPrefix = this.prefix.slice(0, length);\n    const childPrefix = this.prefix.slice(length);\n    this.setPrefix(childPrefix);\n    const staticNode = new StaticNode(parentPrefix);\n    staticNode.staticChildren[childPrefix.charAt(0)] = this;\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;\n    return staticNode;\n  }\n  getNextNode(path, pathIndex, nodeStack, paramsCount) {\n    let node = this.findStaticMatchingChild(path, pathIndex);\n    let parametricBrotherNodeIndex = 0;\n    if (node === undefined) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild;\n      }\n      node = this.parametricChildren[0];\n      parametricBrotherNodeIndex = 1;\n    }\n    if (this.wildcardChild !== undefined) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild\n      });\n    }\n    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i]\n      });\n    }\n    return node;\n  }\n}\nclass ParametricNode extends ParentNode {\n  regex;\n  staticSuffix;\n  _tag = \"ParametricNode\";\n  constructor(regex, staticSuffix, nodePath) {\n    super();\n    this.regex = regex;\n    this.staticSuffix = staticSuffix;\n    this.isRegex = !!regex;\n    this.nodePaths = new Set([nodePath]);\n  }\n  isRegex;\n  nodePaths;\n  getNextNode(path, pathIndex) {\n    return this.findStaticMatchingChild(path, pathIndex);\n  }\n}\nclass WildcardNode extends NodeBase {\n  _tag = \"WildcardNode\";\n  getNextNode(_path, _pathIndex, _nodeStack, _paramsCount) {\n    return undefined;\n  }\n}\nconst assert = (condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\nfunction removeDuplicateSlashes(path) {\n  return path.replace(/\\/\\/+/g, \"/\");\n}\nfunction trimLastSlash(path) {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1);\n  }\n  return path;\n}\nfunction compileCreateParams(params) {\n  const len = params.length;\n  return function (paramsArray) {\n    const paramsObject = {};\n    for (let i = 0; i < len; i++) {\n      paramsObject[params[i]] = paramsArray[i];\n    }\n    return paramsObject;\n  };\n}\nfunction getClosingParenthensePosition(path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n  let parentheses = 1;\n  while (idx < path.length) {\n    idx++;\n    // ignore skipped chars\n    if (path[idx] === \"\\\\\") {\n      idx++;\n      continue;\n    }\n    if (path[idx] === \")\") {\n      parentheses--;\n    } else if (path[idx] === \"(\") {\n      parentheses++;\n    }\n    if (!parentheses) return idx;\n  }\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"');\n}\nfunction trimRegExpStartAndEnd(regexString) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2);\n  }\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);\n  }\n  return regexString;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar(highCharCode, lowCharCode) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return \"%\";\n    if (lowCharCode === 51) return \"#\";\n    if (lowCharCode === 52) return \"$\";\n    if (lowCharCode === 54) return \"&\";\n    if (lowCharCode === 66) return \"+\";\n    if (lowCharCode === 98) return \"+\";\n    if (lowCharCode === 67) return \",\";\n    if (lowCharCode === 99) return \",\";\n    if (lowCharCode === 70) return \"/\";\n    if (lowCharCode === 102) return \"/\";\n    return undefined;\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return \":\";\n    if (lowCharCode === 97) return \":\";\n    if (lowCharCode === 66) return \";\";\n    if (lowCharCode === 98) return \";\";\n    if (lowCharCode === 68) return \"=\";\n    if (lowCharCode === 100) return \"=\";\n    if (lowCharCode === 70) return \"?\";\n    if (lowCharCode === 102) return \"?\";\n    return undefined;\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return \"@\";\n  }\n  return undefined;\n}\nfunction safeDecodeURI(path) {\n  let shouldDecode = false;\n  let shouldDecodeParam = false;\n  let querystring = \"\";\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i);\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1);\n      const lowCharCode = path.charCodeAt(i + 2);\n      if (decodeComponentChar(highCharCode, lowCharCode) === undefined) {\n        shouldDecode = true;\n      } else {\n        shouldDecodeParam = true;\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true;\n          path = path.slice(0, i + 1) + \"25\" + path.slice(i + 1);\n          i += 2;\n        }\n        i += 2;\n      }\n      // Some systems do not follow RFC and separate the path and query\n      // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n      // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1);\n      path = path.slice(0, i);\n      break;\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path;\n  return {\n    path: decodedPath,\n    querystring,\n    shouldDecodeParam\n  };\n}\nfunction safeDecodeURIComponent(uriComponent) {\n  const startIndex = uriComponent.indexOf(\"%\");\n  if (startIndex === -1) return uriComponent;\n  let decoded = \"\";\n  let lastIndex = startIndex;\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1);\n      const lowCharCode = uriComponent.charCodeAt(i + 2);\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar;\n      lastIndex = i + 3;\n    }\n  }\n  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);\n}\nconst httpMethods = [\"ACL\", \"BIND\", \"CHECKOUT\", \"CONNECT\", \"COPY\", \"DELETE\", \"GET\", \"HEAD\", \"LINK\", \"LOCK\", \"M-SEARCH\", \"MERGE\", \"MKACTIVITY\", \"MKCALENDAR\", \"MKCOL\", \"MOVE\", \"NOTIFY\", \"OPTIONS\", \"PATCH\", \"POST\", \"PROPFIND\", \"PROPPATCH\", \"PURGE\", \"PUT\", \"REBIND\", \"REPORT\", \"SEARCH\", \"SOURCE\", \"SUBSCRIBE\", \"TRACE\", \"UNBIND\", \"UNLINK\", \"UNLOCK\", \"UNSUBSCRIBE\"];\n//# sourceMappingURL=router.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW50ZXJuYWwvcm91dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQjtBQUNqQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU8sZ0NBQWdDLFFBQVE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxREFBcUQsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0QscUNBQXFDO0FBQ3JDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haW1wbGFudC8uL25vZGVfbW9kdWxlcy9maW5kLW15LXdheS10cy9kaXN0L2VzbS9pbnRlcm5hbC9yb3V0ZXIuanM/MzllMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBRUyBmcm9tIFwiLi4vUXVlcnlTdHJpbmcuanNcIjtcbmNvbnN0IEZVTExfUEFUSF9SRUdFWFAgPSAvXmh0dHBzPzpcXC9cXC8uKj9cXC8vO1xuY29uc3QgT1BUSU9OQUxfUEFSQU1fUkVHRVhQID0gLyhcXC86W14vKCldKj8pXFw/KFxcLz8pLztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gKG9wdGlvbnMgPSB7fSkgPT4gbmV3IFJvdXRlckltcGwob3B0aW9ucyk7XG5jbGFzcyBSb3V0ZXJJbXBsIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaWdub3JlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZVNsYXNoZXM6IHRydWUsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgIG1heFBhcmFtTGVuZ3RoOiAxMDAsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgfVxuICBvcHRpb25zO1xuICByb3V0ZXMgPSBbXTtcbiAgdHJlZXMgPSB7fTtcbiAgb24obWV0aG9kLCBwYXRoLCBoYW5kbGVyKSB7XG4gICAgY29uc3Qgb3B0aW9uYWxQYXJhbU1hdGNoID0gcGF0aC5tYXRjaChPUFRJT05BTF9QQVJBTV9SRUdFWFApO1xuICAgIGlmIChvcHRpb25hbFBhcmFtTWF0Y2ggJiYgb3B0aW9uYWxQYXJhbU1hdGNoLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2VydChwYXRoLmxlbmd0aCA9PT0gb3B0aW9uYWxQYXJhbU1hdGNoLmluZGV4ICsgb3B0aW9uYWxQYXJhbU1hdGNoWzBdLmxlbmd0aCwgXCJPcHRpb25hbCBQYXJhbWV0ZXIgbmVlZHMgdG8gYmUgdGhlIGxhc3QgcGFyYW1ldGVyIG9mIHRoZSBwYXRoXCIpO1xuICAgICAgY29uc3QgcGF0aEZ1bGwgPSBwYXRoLnJlcGxhY2UoT1BUSU9OQUxfUEFSQU1fUkVHRVhQLCBcIiQxJDJcIik7XG4gICAgICBjb25zdCBwYXRoT3B0aW9uYWwgPSBwYXRoLnJlcGxhY2UoT1BUSU9OQUxfUEFSQU1fUkVHRVhQLCBcIiQyXCIpO1xuICAgICAgdGhpcy5vbihtZXRob2QsIHBhdGhGdWxsLCBoYW5kbGVyKTtcbiAgICAgIHRoaXMub24obWV0aG9kLCBwYXRoT3B0aW9uYWwsIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVNsYXNoZXMpIHtcbiAgICAgIHBhdGggPSByZW1vdmVEdXBsaWNhdGVTbGFzaGVzKHBhdGgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVRyYWlsaW5nU2xhc2gpIHtcbiAgICAgIHBhdGggPSB0cmltTGFzdFNsYXNoKHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2RzID0gdHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIiA/IFttZXRob2RdIDogbWV0aG9kO1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgIHRoaXMuX29uKG1ldGhvZCwgcGF0aCwgaGFuZGxlcik7XG4gICAgfVxuICB9XG4gIGFsbChwYXRoLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5vbihodHRwTWV0aG9kcywgcGF0aCwgaGFuZGxlcik7XG4gIH1cbiAgX29uKG1ldGhvZCwgcGF0aCwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLnRyZWVzW21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50cmVlc1ttZXRob2RdID0gbmV3IFN0YXRpY05vZGUoXCIvXCIpO1xuICAgIH1cbiAgICBsZXQgcGF0dGVybiA9IHBhdGg7XG4gICAgaWYgKHBhdHRlcm4gPT09IFwiKlwiICYmIHRoaXMudHJlZXNbbWV0aG9kXS5wcmVmaXgubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um9vdCA9IHRoaXMudHJlZXNbbWV0aG9kXTtcbiAgICAgIHRoaXMudHJlZXNbbWV0aG9kXSA9IG5ldyBTdGF0aWNOb2RlKFwiXCIpO1xuICAgICAgdGhpcy50cmVlc1ttZXRob2RdLnN0YXRpY0NoaWxkcmVuW1wiL1wiXSA9IGN1cnJlbnRSb290O1xuICAgIH1cbiAgICBsZXQgcGFyZW50Tm9kZVBhdGhJbmRleCA9IHRoaXMudHJlZXNbbWV0aG9kXS5wcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IHRoaXMudHJlZXNbbWV0aG9kXTtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGF0dGVybi5jaGFyQ29kZUF0KGkpID09PSA1OCAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoaSArIDEpID09PSA1OCkge1xuICAgICAgICAvLyBJdCdzIGEgZG91YmxlIGNvbG9uXG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1BhcmFtZXRyaWNOb2RlID0gcGF0dGVybi5jaGFyQ29kZUF0KGkpID09PSA1OCAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoaSArIDEpICE9PSA1ODtcbiAgICAgIGNvbnN0IGlzV2lsZGNhcmROb2RlID0gcGF0dGVybi5jaGFyQ29kZUF0KGkpID09PSA0MjtcbiAgICAgIGlmIChpc1BhcmFtZXRyaWNOb2RlIHx8IGlzV2lsZGNhcmROb2RlIHx8IGkgPT09IHBhdHRlcm4ubGVuZ3RoICYmIGkgIT09IHBhcmVudE5vZGVQYXRoSW5kZXgpIHtcbiAgICAgICAgbGV0IHN0YXRpY05vZGVQYXRoID0gcGF0dGVybi5zbGljZShwYXJlbnROb2RlUGF0aEluZGV4LCBpKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICAgIHN0YXRpY05vZGVQYXRoID0gc3RhdGljTm9kZVBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWNOb2RlUGF0aCA9IHN0YXRpY05vZGVQYXRoLnNwbGl0KFwiOjpcIikuam9pbihcIjpcIik7XG4gICAgICAgIHN0YXRpY05vZGVQYXRoID0gc3RhdGljTm9kZVBhdGguc3BsaXQoXCIlXCIpLmpvaW4oXCIlMjVcIik7XG4gICAgICAgIC8vIGFkZCB0aGUgc3RhdGljIHBhcnQgb2YgdGhlIHJvdXRlIHRvIHRoZSB0cmVlXG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuY3JlYXRlU3RhdGljQ2hpbGQoc3RhdGljTm9kZVBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFyYW1ldHJpY05vZGUpIHtcbiAgICAgICAgbGV0IGlzUmVnZXhOb2RlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlZ2V4cHMgPSBbXTtcbiAgICAgICAgbGV0IGxhc3RQYXJhbVN0YXJ0SW5kZXggPSBpICsgMTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGxhc3RQYXJhbVN0YXJ0SW5kZXg7OyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IHBhdHRlcm4uY2hhckNvZGVBdChqKTtcbiAgICAgICAgICBjb25zdCBpc1JlZ2V4UGFyYW0gPSBjaGFyQ29kZSA9PT0gNDA7XG4gICAgICAgICAgY29uc3QgaXNTdGF0aWNQYXJ0ID0gY2hhckNvZGUgPT09IDQ1IHx8IGNoYXJDb2RlID09PSA0NjtcbiAgICAgICAgICBjb25zdCBpc0VuZE9mTm9kZSA9IGNoYXJDb2RlID09PSA0NyB8fCBqID09PSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaXNSZWdleFBhcmFtIHx8IGlzU3RhdGljUGFydCB8fCBpc0VuZE9mTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGF0dGVybi5zbGljZShsYXN0UGFyYW1TdGFydEluZGV4LCBqKTtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtTmFtZSk7XG4gICAgICAgICAgICBpc1JlZ2V4Tm9kZSA9IGlzUmVnZXhOb2RlIHx8IGlzUmVnZXhQYXJhbSB8fCBpc1N0YXRpY1BhcnQ7XG4gICAgICAgICAgICBpZiAoaXNSZWdleFBhcmFtKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZE9mUmVnZXhJbmRleCA9IGdldENsb3NpbmdQYXJlbnRoZW5zZVBvc2l0aW9uKHBhdHRlcm4sIGopO1xuICAgICAgICAgICAgICBjb25zdCByZWdleFN0cmluZyA9IHBhdHRlcm4uc2xpY2UoaiwgZW5kT2ZSZWdleEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgIHJlZ2V4cHMucHVzaCh0cmltUmVnRXhwU3RhcnRBbmRFbmQocmVnZXhTdHJpbmcpKTtcbiAgICAgICAgICAgICAgaiA9IGVuZE9mUmVnZXhJbmRleCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdleHBzLnB1c2goXCIoLio/KVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY1BhcnRTdGFydEluZGV4ID0gajtcbiAgICAgICAgICAgIGZvciAoOyBqIDwgcGF0dGVybi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IHBhdHRlcm4uY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSA0NykgYnJlYWs7XG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PT0gNTgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaiArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhckNvZGUgPT09IDU4KSBqKys7ZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXRpY1BhcnQgPSBwYXR0ZXJuLnNsaWNlKHN0YXRpY1BhcnRTdGFydEluZGV4LCBqKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNQYXJ0KSB7XG4gICAgICAgICAgICAgIHN0YXRpY1BhcnQgPSBzdGF0aWNQYXJ0LnNwbGl0KFwiOjpcIikuam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIHN0YXRpY1BhcnQgPSBzdGF0aWNQYXJ0LnNwbGl0KFwiJVwiKS5qb2luKFwiJTI1XCIpO1xuICAgICAgICAgICAgICByZWdleHBzLnB1c2goZXNjYXBlUmVnRXhwKHN0YXRpY1BhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RQYXJhbVN0YXJ0SW5kZXggPSBqICsgMTtcbiAgICAgICAgICAgIGlmIChpc0VuZE9mTm9kZSB8fCBwYXR0ZXJuLmNoYXJDb2RlQXQoaikgPT09IDQ3IHx8IGogPT09IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGVQYXR0ZXJuID0gaXNSZWdleE5vZGUgPyBcIigpXCIgKyBzdGF0aWNQYXJ0IDogc3RhdGljUGFydDtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZVBhdGggPSBwYXR0ZXJuLnNsaWNlKGksIGopO1xuICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgwLCBpICsgMSkgKyBub2RlUGF0dGVybiArIHBhdHRlcm4uc2xpY2Uoaik7XG4gICAgICAgICAgICAgIGkgKz0gbm9kZVBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGlzUmVnZXhOb2RlID8gbmV3IFJlZ0V4cChcIl5cIiArIHJlZ2V4cHMuam9pbihcIlwiKSArIFwiJFwiKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5jcmVhdGVQYXJhbWV0cmljQ2hpbGQocmVnZXgsIHN0YXRpY1BhcnQsIG5vZGVQYXRoKTtcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZVBhdGhJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNXaWxkY2FyZE5vZGUpIHtcbiAgICAgICAgLy8gYWRkIHRoZSB3aWxkY2FyZCBwYXJhbWV0ZXJcbiAgICAgICAgcGFyYW1zLnB1c2goXCIqXCIpO1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmNyZWF0ZVdpbGRjYXJkQ2hpbGQoKTtcbiAgICAgICAgcGFyZW50Tm9kZVBhdGhJbmRleCA9IGkgKyAxO1xuICAgICAgICBpZiAoaSAhPT0gcGF0dGVybi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lsZGNhcmQgbXVzdCBiZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gdGhlIHJvdXRlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLmNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgcGF0dGVybiA9IFwiLypcIjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBleGlzdFJvdXRlIG9mIHRoaXMucm91dGVzKSB7XG4gICAgICBpZiAoZXhpc3RSb3V0ZS5tZXRob2QgPT09IG1ldGhvZCAmJiBleGlzdFJvdXRlLnBhdHRlcm4gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2QgJyR7bWV0aG9kfScgYWxyZWFkeSBkZWNsYXJlZCBmb3Igcm91dGUgJyR7cGF0dGVybn0nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJvdXRlID0ge1xuICAgICAgbWV0aG9kLFxuICAgICAgcGF0aCxcbiAgICAgIHBhdHRlcm4sXG4gICAgICBwYXJhbXMsXG4gICAgICBoYW5kbGVyXG4gICAgfTtcbiAgICB0aGlzLnJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICBjdXJyZW50Tm9kZS5hZGRSb3V0ZShyb3V0ZSk7XG4gIH1cbiAgaGFzKG1ldGhvZCwgcGF0aCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnRyZWVzW21ldGhvZF07XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0aWNOb2RlID0gbm9kZS5nZXRTdGF0aWNDaGlsZChwYXRoKTtcbiAgICBpZiAoc3RhdGljTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdGF0aWNOb2RlLmlzTGVhZk5vZGU7XG4gIH1cbiAgZmluZChtZXRob2QsIHBhdGgpIHtcbiAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnRyZWVzW21ldGhvZF07XG4gICAgaWYgKGN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdCgwKSAhPT0gNDcpIHtcbiAgICAgIC8vIDQ3IGlzICcvJ1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShGVUxMX1BBVEhfUkVHRVhQLCBcIi9cIik7XG4gICAgfVxuICAgIC8vIFRoaXMgbXVzdCBiZSBydW4gYmVmb3JlIHNhbml0aXplVXJsIGFzIHRoZSByZXN1bHRpbmcgZnVuY3Rpb25cbiAgICAvLyAuc2xpY2VQYXJhbWV0ZXIgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIHNhbWUgVVJMIHN0cmluZyB1c2VkXG4gICAgLy8gdGhyb3VnaG91dCB0aGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlRHVwbGljYXRlU2xhc2hlcykge1xuICAgICAgcGF0aCA9IHJlbW92ZUR1cGxpY2F0ZVNsYXNoZXMocGF0aCk7XG4gICAgfVxuICAgIGxldCBzYW5pdGl6ZWRVcmw7XG4gICAgbGV0IHF1ZXJ5c3RyaW5nO1xuICAgIGxldCBzaG91bGREZWNvZGVQYXJhbTtcbiAgICB0cnkge1xuICAgICAgc2FuaXRpemVkVXJsID0gc2FmZURlY29kZVVSSShwYXRoKTtcbiAgICAgIHBhdGggPSBzYW5pdGl6ZWRVcmwucGF0aDtcbiAgICAgIHF1ZXJ5c3RyaW5nID0gc2FuaXRpemVkVXJsLnF1ZXJ5c3RyaW5nO1xuICAgICAgc2hvdWxkRGVjb2RlUGFyYW0gPSBzYW5pdGl6ZWRVcmwuc2hvdWxkRGVjb2RlUGFyYW07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlVHJhaWxpbmdTbGFzaCkge1xuICAgICAgcGF0aCA9IHRyaW1MYXN0U2xhc2gocGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpblBhdGggPSBwYXRoO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHBhdGggPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGNvbnN0IG1heFBhcmFtTGVuZ3RoID0gdGhpcy5vcHRpb25zLm1heFBhcmFtTGVuZ3RoO1xuICAgIGxldCBwYXRoSW5kZXggPSBjdXJyZW50Tm9kZS5wcmVmaXgubGVuZ3RoO1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGNvbnN0IHBhdGhMZW4gPSBwYXRoLmxlbmd0aDtcbiAgICBjb25zdCBicm90aGVyc05vZGVzU3RhY2sgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHBhdGhJbmRleCA9PT0gcGF0aExlbiAmJiBjdXJyZW50Tm9kZS5pc0xlYWZOb2RlKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IGN1cnJlbnROb2RlLmhhbmRsZXJTdG9yYWdlPy5maW5kKCk7XG4gICAgICAgIGlmIChoYW5kbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGUuaGFuZGxlcixcbiAgICAgICAgICAgIHBhcmFtczogaGFuZGxlLmNyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiBRUy5wYXJzZShxdWVyeXN0cmluZylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbm9kZSA9IGN1cnJlbnROb2RlLmdldE5leHROb2RlKHBhdGgsIHBhdGhJbmRleCwgYnJvdGhlcnNOb2Rlc1N0YWNrLCBwYXJhbXMubGVuZ3RoKTtcbiAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGJyb3RoZXJzTm9kZXNTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyb3RoZXJOb2RlU3RhdGUgPSBicm90aGVyc05vZGVzU3RhY2sucG9wKCk7XG4gICAgICAgIHBhdGhJbmRleCA9IGJyb3RoZXJOb2RlU3RhdGUuYnJvdGhlclBhdGhJbmRleDtcbiAgICAgICAgcGFyYW1zLnNwbGljZShicm90aGVyTm9kZVN0YXRlLnBhcmFtc0NvdW50KTtcbiAgICAgICAgbm9kZSA9IGJyb3RoZXJOb2RlU3RhdGUuYnJvdGhlck5vZGU7XG4gICAgICB9XG4gICAgICBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAvLyBzdGF0aWMgcm91dGVcbiAgICAgIGlmIChjdXJyZW50Tm9kZS5fdGFnID09PSBcIlN0YXRpY05vZGVcIikge1xuICAgICAgICBwYXRoSW5kZXggKz0gY3VycmVudE5vZGUucHJlZml4Lmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudE5vZGUuX3RhZyA9PT0gXCJXaWxkY2FyZE5vZGVcIikge1xuICAgICAgICBsZXQgcGFyYW0gPSBvcmlnaW5QYXRoLnNsaWNlKHBhdGhJbmRleCk7XG4gICAgICAgIGlmIChzaG91bGREZWNvZGVQYXJhbSkge1xuICAgICAgICAgIHBhcmFtID0gc2FmZURlY29kZVVSSUNvbXBvbmVudChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICBwYXRoSW5kZXggPSBwYXRoTGVuO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50Tm9kZS5fdGFnID09PSBcIlBhcmFtZXRyaWNOb2RlXCIpIHtcbiAgICAgICAgbGV0IHBhcmFtRW5kSW5kZXggPSBvcmlnaW5QYXRoLmluZGV4T2YoXCIvXCIsIHBhdGhJbmRleCk7XG4gICAgICAgIGlmIChwYXJhbUVuZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHBhcmFtRW5kSW5kZXggPSBwYXRoTGVuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbSA9IG9yaWdpblBhdGguc2xpY2UocGF0aEluZGV4LCBwYXJhbUVuZEluZGV4KTtcbiAgICAgICAgaWYgKHNob3VsZERlY29kZVBhcmFtKSB7XG4gICAgICAgICAgcGFyYW0gPSBzYWZlRGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE5vZGUucmVnZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZWRQYXJhbWV0ZXJzID0gY3VycmVudE5vZGUucmVnZXguZXhlYyhwYXJhbSk7XG4gICAgICAgICAgaWYgKG1hdGNoZWRQYXJhbWV0ZXJzID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1hdGNoZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkUGFyYW0gPSBtYXRjaGVkUGFyYW1ldGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkUGFyYW0ubGVuZ3RoID4gbWF4UGFyYW1MZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKG1hdGNoZWRQYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwYXJhbS5sZW5ndGggPiBtYXhQYXJhbUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHBhdGhJbmRleCA9IHBhcmFtRW5kSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBIYW5kbGVyU3RvcmFnZSB7XG4gIGhhbmRsZXJzID0gW107XG4gIHVuY29uc3RyYWluZWRIYW5kbGVyO1xuICBmaW5kKCkge1xuICAgIHJldHVybiB0aGlzLnVuY29uc3RyYWluZWRIYW5kbGVyO1xuICB9XG4gIGFkZChyb3V0ZSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBwYXJhbXM6IHJvdXRlLnBhcmFtcyxcbiAgICAgIGhhbmRsZXI6IHJvdXRlLmhhbmRsZXIsXG4gICAgICBjcmVhdGVQYXJhbXM6IGNvbXBpbGVDcmVhdGVQYXJhbXMocm91dGUucGFyYW1zKVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgIHRoaXMudW5jb25zdHJhaW5lZEhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzWzBdO1xuICB9XG59XG5jbGFzcyBOb2RlQmFzZSB7XG4gIGlzTGVhZk5vZGUgPSBmYWxzZTtcbiAgcm91dGVzO1xuICBoYW5kbGVyU3RvcmFnZTtcbiAgYWRkUm91dGUocm91dGUpIHtcbiAgICBpZiAodGhpcy5yb3V0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yb3V0ZXMgPSBbcm91dGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFuZGxlclN0b3JhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oYW5kbGVyU3RvcmFnZSA9IG5ldyBIYW5kbGVyU3RvcmFnZSgpO1xuICAgIH1cbiAgICB0aGlzLmlzTGVhZk5vZGUgPSB0cnVlO1xuICAgIHRoaXMuaGFuZGxlclN0b3JhZ2UuYWRkKHJvdXRlKTtcbiAgfVxufVxuY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgc3RhdGljQ2hpbGRyZW4gPSB7fTtcbiAgZmluZFN0YXRpY01hdGNoaW5nQ2hpbGQocGF0aCwgcGF0aEluZGV4KSB7XG4gICAgY29uc3Qgc3RhdGljQ2hpbGQgPSB0aGlzLnN0YXRpY0NoaWxkcmVuW3BhdGguY2hhckF0KHBhdGhJbmRleCldO1xuICAgIGlmIChzdGF0aWNDaGlsZCA9PT0gdW5kZWZpbmVkIHx8ICFzdGF0aWNDaGlsZC5tYXRjaFByZWZpeChwYXRoLCBwYXRoSW5kZXgpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGljQ2hpbGQ7XG4gIH1cbiAgZ2V0U3RhdGljQ2hpbGQocGF0aCwgcGF0aEluZGV4ID0gMCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gcGF0aEluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qgc3RhdGljQ2hpbGQgPSB0aGlzLmZpbmRTdGF0aWNNYXRjaGluZ0NoaWxkKHBhdGgsIHBhdGhJbmRleCk7XG4gICAgaWYgKHN0YXRpY0NoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdGF0aWNDaGlsZC5nZXRTdGF0aWNDaGlsZChwYXRoLCBwYXRoSW5kZXggKyBzdGF0aWNDaGlsZC5wcmVmaXgubGVuZ3RoKTtcbiAgfVxuICBjcmVhdGVTdGF0aWNDaGlsZChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGV0IHN0YXRpY0NoaWxkID0gdGhpcy5zdGF0aWNDaGlsZHJlbltwYXRoLmNoYXJBdCgwKV07XG4gICAgaWYgKHN0YXRpY0NoaWxkKSB7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICBmb3IgKDsgaSA8IHN0YXRpY0NoaWxkLnByZWZpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpICE9PSBzdGF0aWNDaGlsZC5wcmVmaXguY2hhckNvZGVBdChpKSkge1xuICAgICAgICAgIHN0YXRpY0NoaWxkID0gc3RhdGljQ2hpbGQuc3BsaXQodGhpcywgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0aWNDaGlsZC5jcmVhdGVTdGF0aWNDaGlsZChwYXRoLnNsaWNlKGkpKTtcbiAgICB9XG4gICAgY29uc3QgbGFiZWwgPSBwYXRoLmNoYXJBdCgwKTtcbiAgICB0aGlzLnN0YXRpY0NoaWxkcmVuW2xhYmVsXSA9IG5ldyBTdGF0aWNOb2RlKHBhdGgpO1xuICAgIHJldHVybiB0aGlzLnN0YXRpY0NoaWxkcmVuW2xhYmVsXTtcbiAgfVxufVxuY2xhc3MgU3RhdGljTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICBfdGFnID0gXCJTdGF0aWNOb2RlXCI7XG4gIGNvbnN0cnVjdG9yKHByZWZpeCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXRQcmVmaXgocHJlZml4KTtcbiAgfVxuICBwcmVmaXg7XG4gIG1hdGNoUHJlZml4O1xuICBwYXJhbWV0cmljQ2hpbGRyZW4gPSBbXTtcbiAgd2lsZGNhcmRDaGlsZDtcbiAgc2V0UHJlZml4KHByZWZpeCkge1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLm1hdGNoUHJlZml4ID0gKF9wYXRoLCBfcGF0aEluZGV4KSA9PiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgdGhpcy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uIChwYXRoLCBwYXRoSW5kZXgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQocGF0aEluZGV4ICsgaSkgIT09IHRoaXMucHJlZml4LmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBnZXRQYXJhbWV0cmljQ2hpbGQocmVnZXgpIHtcbiAgICBpZiAocmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldHJpY0NoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuaXNSZWdleCA9PT0gZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSByZWdleC5zb3VyY2U7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1ldHJpY0NoaWxkcmVuLmZpbmQoY2hpbGQgPT4ge1xuICAgICAgaWYgKGNoaWxkLnJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkLnJlZ2V4LnNvdXJjZSA9PT0gc291cmNlO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVBhcmFtZXRyaWNDaGlsZChyZWdleCwgc3RhdGljU3VmZml4LCBub2RlUGF0aCkge1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0UGFyYW1ldHJpY0NoaWxkKHJlZ2V4KTtcbiAgICBpZiAoY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hpbGQubm9kZVBhdGhzLmFkZChub2RlUGF0aCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGNoaWxkID0gbmV3IFBhcmFtZXRyaWNOb2RlKHJlZ2V4LCBzdGF0aWNTdWZmaXgsIG5vZGVQYXRoKTtcbiAgICB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbi5zb3J0KChjaGlsZDEsIGNoaWxkMikgPT4ge1xuICAgICAgaWYgKCFjaGlsZDEuaXNSZWdleCkgcmV0dXJuIDE7XG4gICAgICBpZiAoIWNoaWxkMi5pc1JlZ2V4KSByZXR1cm4gLTE7XG4gICAgICBpZiAoY2hpbGQxLnN0YXRpY1N1ZmZpeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICAgIGlmIChjaGlsZDIuc3RhdGljU3VmZml4ID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICAgIGlmIChjaGlsZDIuc3RhdGljU3VmZml4LmVuZHNXaXRoKGNoaWxkMS5zdGF0aWNTdWZmaXgpKSByZXR1cm4gMTtcbiAgICAgIGlmIChjaGlsZDEuc3RhdGljU3VmZml4LmVuZHNXaXRoKGNoaWxkMi5zdGF0aWNTdWZmaXgpKSByZXR1cm4gLTE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbiAgY3JlYXRlV2lsZGNhcmRDaGlsZCgpIHtcbiAgICBpZiAodGhpcy53aWxkY2FyZENoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lsZGNhcmRDaGlsZCA9IG5ldyBXaWxkY2FyZE5vZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2lsZGNhcmRDaGlsZDtcbiAgfVxuICBzcGxpdChwYXJlbnROb2RlLCBsZW5ndGgpIHtcbiAgICBjb25zdCBwYXJlbnRQcmVmaXggPSB0aGlzLnByZWZpeC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIGNvbnN0IGNoaWxkUHJlZml4ID0gdGhpcy5wcmVmaXguc2xpY2UobGVuZ3RoKTtcbiAgICB0aGlzLnNldFByZWZpeChjaGlsZFByZWZpeCk7XG4gICAgY29uc3Qgc3RhdGljTm9kZSA9IG5ldyBTdGF0aWNOb2RlKHBhcmVudFByZWZpeCk7XG4gICAgc3RhdGljTm9kZS5zdGF0aWNDaGlsZHJlbltjaGlsZFByZWZpeC5jaGFyQXQoMCldID0gdGhpcztcbiAgICBwYXJlbnROb2RlLnN0YXRpY0NoaWxkcmVuW3BhcmVudFByZWZpeC5jaGFyQXQoMCldID0gc3RhdGljTm9kZTtcbiAgICByZXR1cm4gc3RhdGljTm9kZTtcbiAgfVxuICBnZXROZXh0Tm9kZShwYXRoLCBwYXRoSW5kZXgsIG5vZGVTdGFjaywgcGFyYW1zQ291bnQpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZmluZFN0YXRpY01hdGNoaW5nQ2hpbGQocGF0aCwgcGF0aEluZGV4KTtcbiAgICBsZXQgcGFyYW1ldHJpY0Jyb3RoZXJOb2RlSW5kZXggPSAwO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lsZGNhcmRDaGlsZDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlblswXTtcbiAgICAgIHBhcmFtZXRyaWNCcm90aGVyTm9kZUluZGV4ID0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMud2lsZGNhcmRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlU3RhY2sucHVzaCh7XG4gICAgICAgIHBhcmFtc0NvdW50LFxuICAgICAgICBicm90aGVyUGF0aEluZGV4OiBwYXRoSW5kZXgsXG4gICAgICAgIGJyb3RoZXJOb2RlOiB0aGlzLndpbGRjYXJkQ2hpbGRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSBwYXJhbWV0cmljQnJvdGhlck5vZGVJbmRleDsgaS0tKSB7XG4gICAgICBub2RlU3RhY2sucHVzaCh7XG4gICAgICAgIHBhcmFtc0NvdW50LFxuICAgICAgICBicm90aGVyUGF0aEluZGV4OiBwYXRoSW5kZXgsXG4gICAgICAgIGJyb3RoZXJOb2RlOiB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbltpXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5jbGFzcyBQYXJhbWV0cmljTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICByZWdleDtcbiAgc3RhdGljU3VmZml4O1xuICBfdGFnID0gXCJQYXJhbWV0cmljTm9kZVwiO1xuICBjb25zdHJ1Y3RvcihyZWdleCwgc3RhdGljU3VmZml4LCBub2RlUGF0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZWdleCA9IHJlZ2V4O1xuICAgIHRoaXMuc3RhdGljU3VmZml4ID0gc3RhdGljU3VmZml4O1xuICAgIHRoaXMuaXNSZWdleCA9ICEhcmVnZXg7XG4gICAgdGhpcy5ub2RlUGF0aHMgPSBuZXcgU2V0KFtub2RlUGF0aF0pO1xuICB9XG4gIGlzUmVnZXg7XG4gIG5vZGVQYXRocztcbiAgZ2V0TmV4dE5vZGUocGF0aCwgcGF0aEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZFN0YXRpY01hdGNoaW5nQ2hpbGQocGF0aCwgcGF0aEluZGV4KTtcbiAgfVxufVxuY2xhc3MgV2lsZGNhcmROb2RlIGV4dGVuZHMgTm9kZUJhc2Uge1xuICBfdGFnID0gXCJXaWxkY2FyZE5vZGVcIjtcbiAgZ2V0TmV4dE5vZGUoX3BhdGgsIF9wYXRoSW5kZXgsIF9ub2RlU3RhY2ssIF9wYXJhbXNDb3VudCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbmNvbnN0IGFzc2VydCA9IChjb25kaXRpb24sIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVTbGFzaGVzKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG59XG5mdW5jdGlvbiB0cmltTGFzdFNsYXNoKHBhdGgpIHtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcpIHtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBjb21waWxlQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCBsZW4gPSBwYXJhbXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtc0FycmF5KSB7XG4gICAgY29uc3QgcGFyYW1zT2JqZWN0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgcGFyYW1zT2JqZWN0W3BhcmFtc1tpXV0gPSBwYXJhbXNBcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtc09iamVjdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsb3NpbmdQYXJlbnRoZW5zZVBvc2l0aW9uKHBhdGgsIGlkeCkge1xuICAvLyBgcGF0aC5pbmRleE9mKClgIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgZmlyc3QgcG9zaXRpb24gb2YgdGhlIGNsb3NpbmcgcGFyZW50aGVzZSxcbiAgLy8gYnV0IGl0J3MgaW5lZmZpY2llbnQgZm9yIGdyb3VwZWQgb3Igd3JvbmcgcmVnZXhwIGV4cHJlc3Npb25zLlxuICAvLyBzZWUgaXNzdWVzICM2MiBhbmQgIzYzIGZvciBtb3JlIGluZm9cbiAgbGV0IHBhcmVudGhlc2VzID0gMTtcbiAgd2hpbGUgKGlkeCA8IHBhdGgubGVuZ3RoKSB7XG4gICAgaWR4Kys7XG4gICAgLy8gaWdub3JlIHNraXBwZWQgY2hhcnNcbiAgICBpZiAocGF0aFtpZHhdID09PSBcIlxcXFxcIikge1xuICAgICAgaWR4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBhdGhbaWR4XSA9PT0gXCIpXCIpIHtcbiAgICAgIHBhcmVudGhlc2VzLS07XG4gICAgfSBlbHNlIGlmIChwYXRoW2lkeF0gPT09IFwiKFwiKSB7XG4gICAgICBwYXJlbnRoZXNlcysrO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudGhlc2VzKSByZXR1cm4gaWR4O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcmVnZXhwIGV4cHJlc3Npb24gaW4gXCInICsgcGF0aCArICdcIicpO1xufVxuZnVuY3Rpb24gdHJpbVJlZ0V4cFN0YXJ0QW5kRW5kKHJlZ2V4U3RyaW5nKSB7XG4gIC8vIHJlbW92ZXMgY2hhcnMgdGhhdCBtYXJrcyBzdGFydCBcIl5cIiBhbmQgZW5kIFwiJFwiIG9mIHJlZ2V4cFxuICBpZiAocmVnZXhTdHJpbmcuY2hhckNvZGVBdCgxKSA9PT0gOTQpIHtcbiAgICByZWdleFN0cmluZyA9IHJlZ2V4U3RyaW5nLnNsaWNlKDAsIDEpICsgcmVnZXhTdHJpbmcuc2xpY2UoMik7XG4gIH1cbiAgaWYgKHJlZ2V4U3RyaW5nLmNoYXJDb2RlQXQocmVnZXhTdHJpbmcubGVuZ3RoIC0gMikgPT09IDM2KSB7XG4gICAgcmVnZXhTdHJpbmcgPSByZWdleFN0cmluZy5zbGljZSgwLCByZWdleFN0cmluZy5sZW5ndGggLSAyKSArIHJlZ2V4U3RyaW5nLnNsaWNlKHJlZ2V4U3RyaW5nLmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiByZWdleFN0cmluZztcbn1cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG4vLyBJdCBtdXN0IHNwb3QgYWxsIHRoZSBjaGFycyB3aGVyZSBkZWNvZGVVUklDb21wb25lbnQoeCkgIT09IGRlY29kZVVSSSh4KVxuLy8gVGhlIGNoYXJzIGFyZTogIyAkICYgKyAsIC8gOiA7ID0gPyBAXG5mdW5jdGlvbiBkZWNvZGVDb21wb25lbnRDaGFyKGhpZ2hDaGFyQ29kZSwgbG93Q2hhckNvZGUpIHtcbiAgaWYgKGhpZ2hDaGFyQ29kZSA9PT0gNTApIHtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDUzKSByZXR1cm4gXCIlXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA1MSkgcmV0dXJuIFwiI1wiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNTIpIHJldHVybiBcIiRcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDU0KSByZXR1cm4gXCImXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA2NikgcmV0dXJuIFwiK1wiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gOTgpIHJldHVybiBcIitcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDY3KSByZXR1cm4gXCIsXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA5OSkgcmV0dXJuIFwiLFwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNzApIHJldHVybiBcIi9cIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDEwMikgcmV0dXJuIFwiL1wiO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGhpZ2hDaGFyQ29kZSA9PT0gNTEpIHtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDY1KSByZXR1cm4gXCI6XCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA5NykgcmV0dXJuIFwiOlwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNjYpIHJldHVybiBcIjtcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDk4KSByZXR1cm4gXCI7XCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA2OCkgcmV0dXJuIFwiPVwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gMTAwKSByZXR1cm4gXCI9XCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA3MCkgcmV0dXJuIFwiP1wiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gMTAyKSByZXR1cm4gXCI/XCI7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaGlnaENoYXJDb2RlID09PSA1MiAmJiBsb3dDaGFyQ29kZSA9PT0gNDgpIHtcbiAgICByZXR1cm4gXCJAXCI7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNhZmVEZWNvZGVVUkkocGF0aCkge1xuICBsZXQgc2hvdWxkRGVjb2RlID0gZmFsc2U7XG4gIGxldCBzaG91bGREZWNvZGVQYXJhbSA9IGZhbHNlO1xuICBsZXQgcXVlcnlzdHJpbmcgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY2hhckNvZGUgPT09IDM3KSB7XG4gICAgICBjb25zdCBoaWdoQ2hhckNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgY29uc3QgbG93Q2hhckNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSArIDIpO1xuICAgICAgaWYgKGRlY29kZUNvbXBvbmVudENoYXIoaGlnaENoYXJDb2RlLCBsb3dDaGFyQ29kZSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzaG91bGREZWNvZGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlUGFyYW0gPSB0cnVlO1xuICAgICAgICAvLyAlMjUgLSBlbmNvZGVkICUgY2hhci4gV2UgbmVlZCB0byBlbmNvZGUgb25lIG1vcmUgdGltZSB0byBwcmV2ZW50IGRvdWJsZSBkZWNvZGluZ1xuICAgICAgICBpZiAoaGlnaENoYXJDb2RlID09PSA1MCAmJiBsb3dDaGFyQ29kZSA9PT0gNTMpIHtcbiAgICAgICAgICBzaG91bGREZWNvZGUgPSB0cnVlO1xuICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGkgKyAxKSArIFwiMjVcIiArIHBhdGguc2xpY2UoaSArIDEpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBpICs9IDI7XG4gICAgICB9XG4gICAgICAvLyBTb21lIHN5c3RlbXMgZG8gbm90IGZvbGxvdyBSRkMgYW5kIHNlcGFyYXRlIHRoZSBwYXRoIGFuZCBxdWVyeVxuICAgICAgLy8gc3RyaW5nIHdpdGggYSBgO2AgY2hhcmFjdGVyIChjb2RlIDU5KSwgZS5nLiBgL2Zvbztqc2Vzc2lvbmlkPTEyMzQ1NmAuXG4gICAgICAvLyBUaHVzLCB3ZSBuZWVkIHRvIHNwbGl0IG9uIGA7YCBhcyB3ZWxsIGFzIGA/YCBhbmQgYCNgLlxuICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT09IDYzIHx8IGNoYXJDb2RlID09PSA1OSB8fCBjaGFyQ29kZSA9PT0gMzUpIHtcbiAgICAgIHF1ZXJ5c3RyaW5nID0gcGF0aC5zbGljZShpICsgMSk7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNvZGVkUGF0aCA9IHNob3VsZERlY29kZSA/IGRlY29kZVVSSShwYXRoKSA6IHBhdGg7XG4gIHJldHVybiB7XG4gICAgcGF0aDogZGVjb2RlZFBhdGgsXG4gICAgcXVlcnlzdHJpbmcsXG4gICAgc2hvdWxkRGVjb2RlUGFyYW1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNhZmVEZWNvZGVVUklDb21wb25lbnQodXJpQ29tcG9uZW50KSB7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSB1cmlDb21wb25lbnQuaW5kZXhPZihcIiVcIik7XG4gIGlmIChzdGFydEluZGV4ID09PSAtMSkgcmV0dXJuIHVyaUNvbXBvbmVudDtcbiAgbGV0IGRlY29kZWQgPSBcIlwiO1xuICBsZXQgbGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCB1cmlDb21wb25lbnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodXJpQ29tcG9uZW50LmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICBjb25zdCBoaWdoQ2hhckNvZGUgPSB1cmlDb21wb25lbnQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICBjb25zdCBsb3dDaGFyQ29kZSA9IHVyaUNvbXBvbmVudC5jaGFyQ29kZUF0KGkgKyAyKTtcbiAgICAgIGNvbnN0IGRlY29kZWRDaGFyID0gZGVjb2RlQ29tcG9uZW50Q2hhcihoaWdoQ2hhckNvZGUsIGxvd0NoYXJDb2RlKTtcbiAgICAgIGRlY29kZWQgKz0gdXJpQ29tcG9uZW50LnNsaWNlKGxhc3RJbmRleCwgaSkgKyBkZWNvZGVkQ2hhcjtcbiAgICAgIGxhc3RJbmRleCA9IGkgKyAzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXJpQ29tcG9uZW50LnNsaWNlKDAsIHN0YXJ0SW5kZXgpICsgZGVjb2RlZCArIHVyaUNvbXBvbmVudC5zbGljZShsYXN0SW5kZXgpO1xufVxuY29uc3QgaHR0cE1ldGhvZHMgPSBbXCJBQ0xcIiwgXCJCSU5EXCIsIFwiQ0hFQ0tPVVRcIiwgXCJDT05ORUNUXCIsIFwiQ09QWVwiLCBcIkRFTEVURVwiLCBcIkdFVFwiLCBcIkhFQURcIiwgXCJMSU5LXCIsIFwiTE9DS1wiLCBcIk0tU0VBUkNIXCIsIFwiTUVSR0VcIiwgXCJNS0FDVElWSVRZXCIsIFwiTUtDQUxFTkRBUlwiLCBcIk1LQ09MXCIsIFwiTU9WRVwiLCBcIk5PVElGWVwiLCBcIk9QVElPTlNcIiwgXCJQQVRDSFwiLCBcIlBPU1RcIiwgXCJQUk9QRklORFwiLCBcIlBST1BQQVRDSFwiLCBcIlBVUkdFXCIsIFwiUFVUXCIsIFwiUkVCSU5EXCIsIFwiUkVQT1JUXCIsIFwiU0VBUkNIXCIsIFwiU09VUkNFXCIsIFwiU1VCU0NSSUJFXCIsIFwiVFJBQ0VcIiwgXCJVTkJJTkRcIiwgXCJVTkxJTktcIiwgXCJVTkxPQ0tcIiwgXCJVTlNVQlNDUklCRVwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js\n");

/***/ })

};
;